#+TITLE: Notes on Computability and Computational Complexity

Collection of notes and code about the Computability and Computational Complexity course, part of the Master in Computer Science at the Universit√† di Trento (UNITN).

* Computational Complexity
** $\text{DTIME}$ and $\text{NTIME}$

From now on we focus our attention on the class of problems    \begin{equation}
R=\{L|\exists \text{ Turing machine } M \text{ that decides } L \} \notag
\end{equation}. Considering the languages that can be decided in $O(f(n)), f: \mathbb{N} \rightarrow \mathbb{N}$, we have
- $\text{DTIME}(f(n))=\{L|L\in R, T_M(n)\in O(f(n))\}$, solvable by a non-deterministic Turing machine.
- $\text{NTIME}(f(n))=\{L|L\in R, NT_M(n)\in O(f(n))\}$, solvable by a non-deterministic Turing machine.
  
** $\textbf{P}$ and $\textbf{NP}$

Considering only the languages that can be decided in polynomial time, we have the following complexity classes
- Polynomial time $\textbf{P} = \bigcup_{c\geq 1} \text{DTIME}(n^c)$, solvable by a deterministic Turing machine
- Nondeterministic polynomial time $\textbf{NP} = \bigcup_{c\geq 1} \text{NTIME}(n^c)$, solvable by a non-deterministic Turing machine

Lets consider a language $L \notin P, L \in NP$, $L$ is a problem such that each candidate solution
1. Is /small/, having polynomial size w.r.t the input
2. Takes polynomial time to be verified

This pattern can implemented efficiently using a non-deterministic
Turing machine where
1. Each path of the computation tree is of polynomial lenght
2. The written result of each path can be verified in polynomial number of steps

The class of Polynomial Certificates $\mathbf{PC}$ collects all the languages s.t.

\begin{equation}
\text{ input } w \in \mathbf{PC} \notag \iff \exists \text{ certificate } u \text{ that proves } w \in L \text{ in polynomial time}
\end{equation}

Since $\mathbf{PC}=\mathbf{NP}$ this is also an alternative definition of the latter.

For sure $P \subseteq NP$, but is $P=NP$? This is still an open question
- A language $L\in \textbf{NP-hard} \iff L' \leq_p L, \forall L'\in \textbf{NP}$. Also note that if $L\in \textbf{NP-hard}\wedge L \leq_p L' \Rightarrow L' \in \textbf{NP-hard}$.
- $\textbf{NP-complete}\subseteq \textbf{NP}$ contains the hardest problems in $\texfbf{NP}$: a language $L\in\textbf{NP-complete}\iff L\in\textbf{NP} \wedge L\in\textbf{NP-hard}$.
- We know that $\textbf{P} = \textbf{NP} \iff \exists L | L \in P \wedge L \in \textbf{NP-complete}$.

This pattern can implemented efficiently using a non-deterministic Turing machine that guesses a /certificate/ for an input $w$.
** $\textbf{P}$ languages

*** Reachability

\begin{equation}
\text{REACHABILITY}=\{(G,s,t)| \exists \text{ a path from node } s \text{ to node } t \text{ in the directed graph } G\} \notag
\end{equation}

\begin{algorithm}[H]
\SetAlgoLined
\KwData{Directed graph $G=(V,E)$ and nodes $s,t$}
\KwResult{$Y$ if there is a path from $s$ to $t$, $N$ otherwise}
 \tcp{Done in constant time w.r.t. input size}
 init an empty queue $Q$\;
 mark node $s$ as $visited$\;
 append $s$ to $Q$\;
 \tcp{At most $|V|$ iterations, visiting all the nodes in $G$}
 \While{$Q$ is not empty}{
  extract node $v$, the first element of $Q$\;
  \If{$v$ is $t$}{
   \Return Y\;
   }
  \tcp{At most $|V|$ iterations, all the the nodes are neighbours of $v$}
  \ForAll{$(v,u) \in E$ s.t. $u$ is not $visited$}{
   mark node $u$ as $visited$\;
   append $u$ to $Q$\;
  }\EndFor
 }
 \Return $N$\;
 \caption{Breadth-first search, in $O(n^2)$ with $n=|V|$}
\end{algorithm}

*** Prime

\begin{equation}
\text{PRIME}=\{<N>|N\text{ is prime}\},\quad <N>\text{ binary encoding of }N \in \mathbb{N} \notag
\end{equation}

\begin{algorithm}[H]
\SetAlgoLined
\KwData{$<N>$}
\KwResult{$Y$ if $N$ is prime, $N$ otherwise}
 \tcp{At most $N$ iterations}
 \ForAll{$k=2$ to $N-1$}{
  \If{$k$ divides $N$}{
   \Return $N$\;
  }
 }\EndFor
 \Return $Y$\;
 \caption{Naive iteration, in $O(N)$}
\end{algorithm}

However, this algorithm is not polynomial in the /size/ of the input: since the input has been encoded in binary, we use $n=\left\lceil \log_2 N \right\rceil$ bits to encode $N$. This means that $N \in O(2^n)$ and the algorithm is exponential w.r.t to the input size.
** $\textbf{NP-complete}$ languages

*** SAT and Cook's Theorem

A CNF (/Conjunctive Normal Form/) is a boolean formula of the form

\begin{equation}
C_1 \wedge C_2 \wedge \cdots \wedge C_n,\quad \text{ with clauses } C_i=(l_1 \vee l_2 \vee \cdots \vee l_k) \text{ having literals } l_j\notag
\end{equation}

\begin{equation}
\varphi=(x_1 \vee x_2 \vee x_2 \vee \bar{x}_3) \wedge (x_4 \vee \bar{x}_5) \wedge (x_1 \vee \bar{x}_5) \notag
\end{equation}

\begin{equation}
\text{SAT}=\{\varphi|\varphi \text{ is a satisfiable CNF}\} \notag
\end{equation}

\begin{algorithm}[H]
\SetAlgoLined
\KwData{A CNF boolean formula $\varphi$}
\KwResult{$Y$ if $\varphi$ is a satisfiable CNF, $N$ otherwise}
 \tcp{At most $m$ iterations, checking all the clauses}
 \ForAll{$C_i$ of $\varphi$}{
  $cvalue = False$\;
  \tcp{At most $c$ iterations, checking all the literals}
  \ForAll{$l_j$ of $C_i$}{
   \If{$l_j = True$}{
    $cvalue = True$\;
    break\;
   }
  }
  \If{cvalue = False}{
   \Return $N$\;
  }
 }
 \Return $Y$\;
 \caption{Naive iterations, in $O(2^n)$ with $n$ clauses}
\end{algorithm}

Cook's theorem states that $\text{SAT} \in \mathbf{NP-complete}$.

*** Independent set

$S$ is an /independent set/ in $G=(V,E)$ if and only if there is no edge connecting any pair of nodes in $S$.

\begin{equation}
\text{IS}=\{ (G,K) |G \text{ undirected graph}, \exists S \text{ independent set s.t. |S|} \ge k\} \notag
\end{equation}

\begin{algorithm}[H]
\SetAlgoLined
\KwData{Undirected graph $G$, cardinality $k$}
\KwResult{$Y$ if $G$ contains an indipendent set $S$ s.t. $|S| \geq k$, $N$ otherwise}
 \tcp{At most $\sum_{i=k}^{n} \binom{n}{i}$ iterations, checking all the possible sets with at least $k$ nodes}
 \ForAll{Set of nodes $S$ s.t. $|S| \geq k$}{
  \tcp{At most $n(n-1)/2$ iterations, checking all the pairs when $|S|=n$}
  \ForAll{$(u,v) \in S$}{
   \If{$(u,v)$ are connected}{
    break\;
   }
  }
  \Return $Y$\;
 }
 \Return $N$\;
 \caption{Naive iterations, in $O(n^2 \sum_{i=k}^n \frac{n!}{i!(n-i)!})$ with $n$ nodes}
\end{algorithm}

$\text{IS} \in \textbf{NP-complete}$ since
1. $\text{IS} \in \textbf{NP}$
2. $\text{IS} \in \textbf{NP-hard}$, we can define a polynomial reduction $\text{EXACT-3-SAT} \leq_p \text{IS}$

*** Vertex cover

$VC$ is a /vertex cover/ in $G=(V,E)$ if and only if all the vertices of $G$ are touched by some node in $VC$.

\begin{equation}
\text{VCOVER}=\{(G,k)|G \text{ undirected graph }, \exists VC \text{ vertex cover s.t. } |VC| \leq k\} \notag
\end{equation}

Notice that $S$ is an independent set in $G$ if and only if $V\setminus S$ is a vertex cover of $G$.

$\text{VCOVER} \in \textbf{NP-complete}$ since
1. $\text{VCOVER} \in \textbf{NP}$
2. $\text{VCOVER} \in \textbf{NP-hard}$, we can define a polynomial reduction $\text{IS} \leq_p \text{VCOVER}$

*** Clique

$C$ is a /clique/ in $G=(V,E)$ if and only if the nodes in $C$ form a fully connected subgraph in $G$.

\begin{equation}
\text{CLIQUE}=\{(G,k)|G \text{ undirected graph }, \exists C \text{ clique s.t. } |VC| \geq k\} \notag
\end{equation}

Let $G'$ have the same nodes as $G$ but "complementary" edges, then a independent set $S$ in $G$ is a clique $C$ in $G'$.

$\text{CLIQUE} \in \textbf{NP-complete}$ since
1. $\text{CLIQUE} \in \textbf{NP}$
2. $\text{CLIQUE} \in \textbf{NP-hard}$, we can define a polynomial reduction $\text{IS} \leq_p \text{CLIQUE}$

*** Binary integer programming

$A \in \mathbb{Z}^{m \times n}$ and $\bar{b} \in \mathbb{Z}^m$ contain respectively the coefficients $a_{ij} \in \mathbb{Z}$ and $b_i \in \mathbb{Z}$ of a system of linear inequalities, and to solve the system means finding a $\bar{x}$ s.t. $A \cdot \bar{x} \leq \bar{b}$.

\begin{equation}
\text{BIP} = \{(A,\bar{b})|A \in \mathbb{Z}^{m \times n}, \bar{b} \in \mathbb{Z}^m, \exists \bar{x}\in \{0,1\}^n | A \cdot \bar{x} \leq \bar{b}\} \notag
\end{equation}

$\text{BIP} \in \textbf{NP-complete}$ since
1. $\text{BIP} \in \textbf{NP}$
2. $\text{BIP} \in \textbf{NP-hard}$, we can define a polynomial reduction $\text{EXACT-3-SAT} \leq_p \text{BIP}$

Also the more general version of the problem $\text{IP} = \{(A,\bar{b})|A \in \mathbb{Z}^{m \times n}, \bar{b} \in \mathbb{Z}^m\} \notag \in \textbf{NP-complete}$

*** Vertex coloring

Given an undirected graph $G=(V,E)$ and $k \in \mathbb{Z}$, a function $\text{k-coloring}: V \rightarrow \{1,2,\dots,k\}$ assigns a color to each node so that $f(u) \neq f(v), \forall \{u,v\} \in E$.

\begin{equation}
\text{VCOL} = \{(G,k)|G \text{ is an undirected graph admitting a k-coloring}\} \notag
\end{equation}

$\text{VCOL} \in \textbf{NP-complete}$ since
1. $\text{VCOL} \in \textbf{NP}$
2. $\text{VCOL} \in \textbf{NP-hard}$, we can define a polynomial reduction $\text{EXACT-3-SAT} \leq_p \text{VCOL}$

Also the more specific version of the problem $\text{3-VCOL} = \{(G,k)|G \text{ is an undirected graph admitting a 3-coloring}\}$
** $\mathbf{coNP}$

Similarly to the $RE$ languages case, the complement of languages in
$\mathbf{NP}$ present an asymmetric behaviour. Considering a NTM
- Accepting requires /at least/ one accepting path
- Rejecting requires /all paths/ to be rejecting

We define the complexity class containing the complements of $\mathbf{NP}$ languages as $\mathbf{coNP} = \{L|\bar{L} \in \mathbf{NP}\}$: note that this is not $L|L \notin \mathbf{NP}$, so $\exists L \in \mathbf{NP} \cap \mathbf{coNP}$. While we still don't know if $\mathbf{NP} = \mathbf{coNP}$, some theorems can help us  to tackle this question
- $\mathbf{NP} = \mathbf{coNP} \iff \exists L \in \mathbf{NP-complete} \cap \mathbf{coNP}$
- $\mathbf{P} \subseteq \mathbf{NP} \cap \mathbf{coNP}$
- $\mathbf{P} = \mathbf{NP} \Rightarrow \mathbf{NP} = \mathbf{coNP}$

*** Factor

\begin{equation}
\text{FACTOR}=\{(N,K)|N \in \mathbb {N} \text{ with at least a prime factor } M \leq k\} \notag
\end{equation}

This is an example of problem in a "/limbo/" between $\mathbf{P}$ and $\mathbf{NP-complete}$, in fact $\text{FACTOR} \in \mathbf{NP} \cap \mathbf{coNP}$. We don't know if $\text{FACTOR} \notin \mathbf{P}$, but the current cryptography field is based on this belief: finding a key of a channel is equivalent to factorize a very large $N$.
** $\textbf{EXP}$ and $\textbf{NEXP}$

Considering the languages that can be decided in exponential time, we have the following complexity classes
- Exponential time $\textbf{P} = \bigcup_{c\geq 1} \text{DTIME}(2^{n^c})$, solvable by a deterministic Turing machine
- Nondeterministic exponential time $\textbf{NP} = \bigcup_{c\geq 1} \text{NTIME}(2^{n^c})$, solvable by a non-deterministic Turing machine
** $\text{DSPACE}$ and $\text{NSPACE}$

We now consider a two-tapes Turing machine with a read-only /input tape/ and a read-write /working tape/, with no need to output anything. The space required by such machine is denoted as $S_M(n)$, the maximum number of cells visited on the working tape for an input of lenght $n$. In the non-deterministic case we must consider all the computation paths.

Let $f: \mathbb{N} \rightarrow \mathbb{N}$, we have
- $\text{DSPACE}(f(n))=\{L|\exists T_M \text{ deciding } L, S_M(n) \in O(f(n))\}$, solvable by a non-deterministic Turing machine using space in the order of $f(n)$.
- $\text{NSPACE}(f(n))=\{L|\exists NT_M \text{ deciding } L, S_M(n) \in O(f(n))\}$, solvable by a non-deterministic Turing machine using space in the order of $f(n)$.
** $\textbf{LOGSPACE}$ and $\textbf{NL}$

Considering only the languages that can be decided with a logarithmic amount of space, we have the following complexity classes
- Logspace $\textbf{LOGSPACE} = \text{DSPACE}(\log n)$, solvable by a deterministic Turing machine
- Nondeterministic logspace $\textbf{NL} = \text{NSPACE}(\log n)$, solvable by a non-deterministic Turing machine

For sure $\textbf{LOGSPACE} \subseteq \textbf{NL}$, but is $\textbf{LOGSPACE}=\textbf{NL}$? This is still an open question
- $L_1 \leq_L L_2$ is a logspace reduction
- A language $L\in \textbf{NL-complete} \iff L \in \textbf{NL} \wedge L' \leq_L L, \forall L'\in \textbf{NL}$.
- We know that $\textbf{LOGSPACE} = \textbf{NL} \iff \exists L | L \in \textbf{LOGSPACE} \wedge L \in \textbf{NL-complete}$.

*** $L_{01} \in \mathbf{LOGSPACE}$ 

\begin{equation}
L_{01} = \{ 0^n1^n | n \geq 0\} \notag
\end{equation}

\begin{algorithm}[H]
\SetAlgoLined
\KwData{Input string $w$}
\KwResult{$Y$ if $w=0^n1^n$, $N$ otherwise}
 \If{w=\{\}}{
  \Return $Y$\;
 }
 $zero\_counter=0$\;
 \While{$input\_cell$ is 0}{
  $zero\_counter=zero\_counter + 1$\;
  read next $input\_cell$\;
 }
 $one\_counter=0$\;
 \While{$input\_cell$ is 1}{
  $one\_counter=one\_counter + 1$\;
  read next $input\_cell$\;
 }
 \eIf{$input\_cell=\_$ and $zero\_counter=one\_counter$}{
  \Return $Y$\;
 }{
  \Return $N$\;
 }
 \tcp{Only two counters are used, each at most $n=|w|$, encoded in binary so $O(\log_2 n)$}
 \caption{Turing machine for $L_{01}$, $S_M(n) \in O(\log_2 n) \Rightarrow L_{01} \in \mathbf{LOGSPACE}$}
\end{algorithm}

*** $\text{REACHABILITY} \in \mathbf{NL-complete}$

\begin{equation}
\text{REACHABILITY} = \{(G,s,t)|\text{ directed graph } G \text{ has a path from } s \text{ to } t\} \notag
\end{equation}

Note that we can store into the working tape a pointer with the position of the input string in the input tape: this pointer would take only $O(\log_2 |w|)$ cells instead of holding the entire string in $O(|w|)$.

\begin{algorithm}[H]
\SetAlgoLined
\KwData{Directed graph $G=(V,E)$ and nodes $s,t$}
\KwResult{$Y$ if there is a path from $s$ to $t$, $N$ otherwise}
 $p$ points to $s$, store $p$ in the working tape\;
 $counter=1$, store $counter$ in the working tape\;
 \#LABEL\;
 \If{$p$ points to $t$}{
  \Return $Y$\;
 }
 Guess a point $v$ in $G$, $p'$ points to $v$\;
 \If{$p$ points to a node with no edge to the node pointed by $p'$}{
  \Return $N$\;
 }
 $p=p'$\;
 $counter=counter+1$\;
 \eIf{counter \leq |V|}{
  \textbf{goto} \#LABEL\;
 }{
  \Return $N$\;
 }
 \caption{Algorithm for $\text{REACHABILITY} \in \mathbf{NL}$}
\end{algorithm}

Furthermore, $\text{REACHABILITY} \in \textbf{NL-complete}$.
** Savitch's Theorem

\begin{equation}
\text{NSPACE}(f(n)) \subseteq \text{DSPACE}(f^2(n)) \quad \forall n \in \mathbb{N}, \forall f:\mathbb{N} \rightarrow \mathbb{N}| f(n) \geq \log n \notag
\end{equation}

When considering space, there is in fact not much difference between deterministic and non-deterministic Turing machines: unlike time, space can be reused.

*** $\mathbf{PSPACE}$ and $\mathbf{NPSPACE}$

\begin{equation}
\mathbf{PSPACE}=\bigcup_{c \geq 1} \text{DSPACE}(n^c),\quad  \mathbf{NSPACE}=\bigcup_{c \geq 1} \text{DSPACE}(n^c) \notag
\end{equation}

From the Savitch's theorem, the following corollary over (at least) polynomial space follows

\begin{equation}
\mathbf{PSPACE} = \mathbf{NPSPACE} \notag
\end{equation}

*** $\text{REACHABILITY} \in \text{DSPACE}((\log_2 n)^2)$

\begin{algorithm}[H]
\SetAlgoLined
\KwData{Directed graph $G=(V,E)$, nodes $s,t$ and an integer $k$}
\KwResult{$Y$ if there is a path from $s$ to $t$ requiring at most $k$ steps, $N$ otherwise}
 \tcp{Does $s$ reach $t$ in zero steps?}
 \If{$k=0$}{
  \eIf{$s=t$}{
   \Return $Y$\;
  }{
   \Return $N$\;
  }
 }

 \tcp{Does $s$ reach $t$ in at most one step?}
 \If{k=1}{
  \eIf{$s=t$ or $(s,t) \in E$}{
   \Return $Y$\;
  }{
   \Return $N$\;
  }
 }

 \tcp{Look for a middle node}
 \ForEach{$u \in V$}{
  \eIf{$\text{exists-path}(G,s,u,\left\lfloor k/2 \right\rfloor)$ and $\text{exists-path}(G,s,u,\left\lceil k/2 \right\rceil)$}{
   \Return $Y$\;
  }{
   \Return $N$\;
  }
 }
 \Return $N$\;
 \caption{\text{exists-path}}
\end{algorithm}
** Overview on time and space complexity classes

Considering space classes, we have $\mathbf{LOGSPACE} \subseteq \mathbf{NL} \subseteq \mathbf{PSPACE} = \mathbf{NPSPACE}$, and their relationship with time classes is as follows
- $\mathbf{LOGSPACE}\math \subseteq \mathbf{P}, \quad \mathbf{NL} \subseteq \mathbf{P}$
- $\mathbf{NP} \subseteq \mathbf{PSPACE}, \quad \mathbf{coNP} \subseteq \mathbf{PSPACE}$
- $\mathbf{PSPACE} \subseteq \mathbf{EXP}$
** Turing Machines with Oracles

\begin{equation}
\text{MIN-COVER}=\{(G,k)|\text{ undirected graph } G, \text{ the smallest vertex cover } VC \text{ is } |VC|=k\} \notag
\end{equation}

Our procedure should both verify that there is a vertex cover of size at most $k$ ($\text{VCOVER} \in \textbf{NP}$) and no vertex cover of size $k-1$ ($\overline{\text{VCOVER}} \in \textbf{coNP}$): we believe that $\textbf{NP} \neq \textbf{coNP}$, so unlikely this can be done in $\textbf{NP}$. We can rephrase the problem as

\begin{equation}
\text{MIN-COVER}=\{(G,k)|(G,k) \in \text{VCOVER} \wedge (G,k-1) \notin \text{VCOVER}\} \notag
\end{equation}

Given a procedure $\text{check-cover}$ deciding $\text{VCOVER}$, we can call it as a sub-routine (an /oracle/). We only need a polynomial number of steps to decide $\text{MIN-cover}$, but the most difficult part done by the oracle.

A Turing machine with an /oracle/ for $L$ has an additional read/write tape, oracle tape, and three more states $q_?, q_{yes}, q_{not}$. To check if $w \in L$, write $w$ in the oracle tape and move to $q_?$: if the next state is $q_{yes}$, then $w \in L$.

Using oracles we can define different complexity classes. Le $C$ be some complexity class
- $\textbf{P}^C=\{L\L \text{ can be decided by a polynomial time } DTM \text{ with an oracle for some language } L' \in C\}$
- $\textbf{NP}^C=\{L\L \text{ can be decided by a polynomial time } NTM \text{ with an oracle for some language } L' \in C\}$

For example, $\text{MIN-VCOVER} \in \texbf{P}^\textbf{NP}$. Note that $\textbf{NP} \subseteq \textbf{P}^\textbf{NP}$ and $\textbf{coNP} \subseteq \textbf{P}^\textbf{NP}$. Using oracles we can also define a /polynomial time heriarchy/, wich is an infinite hiearchy of complexity classes.
** Search problems with decision version

\begin{equation}
\text{FMIN-VCOVER}=\min\{|VC|| VC\text{ is a vertex cover of }G\}\notag
\end{equation}

\begin{algorithm}[H]
\SetAlgoLined
 $k = |V| - 1$\;
 \While{(G,k) \in \text{VCOVER}}{
  k = k -1
 }
 write $k$ in the output tape
\end{algorithm}

Let $\mathbf{FP}$ be the class of search problems that can be solved by a Turing machine with output tape in polynomial time, then $\text{FMIN-VCOVER} \in \textbf{FP}^\textbf{NP}$. We can actually improve the previous algorithm by employing binary search and reducing the number of steps from $O(|V|)$ to $O(\log_2 |V|)$, so $\text{FMIN-VCOVER} \in \textbf{FP}^{\textbf{NP} \left[ \log_2 n \right]}$.
** The Travelling Salesman Problem

We define the /Functional Travelling Salesman Problem/ (FTSP) as, given a weighted undirected graph, finding the minimum cost of an Hamilton cycle (if it exists).

\begin{equation}
\text{TSP} = \{(G,K)|\text{ weighted, undirected graph } G \text{ with an Hamilton cycle costing at most } k\} \notag
\end{equation}

\begin{algorithm}[H]
\SetAlgoLined
 \tcp{$m$ bits to encode each cost + $|E|$ bits to encode each edge $\rightarrow k \in O(2^{m+|E|})$}
 $k$ is the sum of the cost of all edges in $G$\;
 \If{(G,k) \notin \text{TSP}}{
  write $\bot$ in the output tape and halt\;
 }
 \While{(G,k) \in \text{TSP}}{
  $k=k-1$\;
 }
 write $k+1$ in the output tape\;
\end{algorithm}

A better algorithm relies again on binary search, resulting in $\text{FTSP} \in \textbf{FP}^{\textbf{NP}}$.

\begin{algorithm}[H]
\SetAlgoLined
 $a = 0$\;
 \tcp{$m$ bits to encode each cost + $|E|$ bits to encode each edge $\rightarrow b \in O(2^{m+|E|})$}
 $b$ is the sum of the cost of all edges in $G$\;
 \tcp{ binary search, so number of iterations $\in O(\log_2 2^{m+|E|})=O(m+|E|)$}
 \While{a \leq b}{
  $k = \left\lfloor (a+b)/2 \right\rfloor$\;
  \eIf{$(G,k-1) \in \text{TSP}$}{
   \tcp{Cost is striclty smaller than middle point, move interval to the left}
   $b = k-1$\;
  }{
   \eIf{(G,k) \in \text{TSP}}{
    \tcp{$k$ is the minimum cost}
    write $k$ in the output tape and halt\;
   }{
    \tcp{Cost is striclty larger than middle point, move interval to the right}
    $a = k+1$\;
   }
  }
 }
 write $\bot$ in the output tape\;
\end{algorithm}

Finally, since $\text{TSP} \in \textbf{NP-complete}$ also the specific $\text{FTSP} \in \textbf{NP-complete}$.
* Exam discussion 09/02/2021
** Computability part
*** Describe the language

We first need to identify what is the language decided by the Turing machine represented by the scheme, where $\alpha \in \{a,b,c\}$.

#+CAPTION: The scheme provided for the Turing machine to be discussed
[[./img/tm_09022021.jpg]]

From $q_1$ we go to $q_{accept}$ if the input string is empty, otherwise move to $q_2$.

In $q_2$ we always read a symbol $\alpha$ in tape $1$ and move to the right, then we either
- Copy $\alpha$ to tape $2$, move right and stay in $q_2$
- Copy $\alpha$ to tape $3$, move right and move to $q_3$
Note this is a nondeterministic behaviour.

In $q_3$ we either
- Keep copying $\alpha$ in tape $3$, moving right and stay in $q_3$
- Copy $\alpha$ to tape $2$, move right in tape $2$, move left in tape $3$ and move to $q_4$
Also here we have a nondeterministic behaviour.

In $q_4$ we keep copying $\alpha$ to tape $2$ until we reach the end of the string in tape $1$.

When we reach $q_5$, the heads of tape $2$ and $3$ are at the end of the respective strings. We loop in $q_5$ to check that $2$ and $3$ have the same string, when we end with the empty symbol we move to $q_{accept}$.

Finally, the arch from $q_3$ to $q_5$ represents the case where we have read all the string in tape $1$ and skip to the checks made by $q_5$.

To undestand the overall behaviour we explore the possible paths to reach $q_{accept}$
- From $q_1$ to $q_{accept}$, so the empty string ~_~ is part of the language
- $q_1 \rightarrow q_2 \rightarrow q_3 \rightarrow q_5 \rightarrow q_{accept}$
  - $q_2$ copies from tape $1$ to tape $2$, let's call the resulting string in tape $2$ $w_1$
  - $q_3$ copies the part following $w_1$ to tape $3$, let's call it $w_2$
  - The string in tape $1$ is seen as $w_1 w_2$, each possible length of $w_1$ (and $w_2$) is tested on a different computational path
  - $q_5$ checks that $w_1=w_2$, and if so we end up in $q_{accept}$
    This means that strings of the form $w_1w_2$ s.t. $w_1=w_2,\quad w_1,w_2 \in \{a,b,c\}^+$ are part of the language
- $q_1 \rightarrow q_2 \rightarrow q_3 \rightarrow q_4 \rightarrow q_5 \rightarrow q_{accept}$
  - $q_2$ copies from tape $1$ to tape $2$, let's call the resulting string in tape $2$ $w_1$
  - $q_3$ copies the part following $w_1$ to tape $3$, let's call it $w_2$
  - $q_4$ copies the part following $w_2$ to tape $2$, let's call it $w_3$
  - The string in tape $1$ is seen as $w_1 w_2 w_3$, each possible length of $w_1, w_2, w_3$ is tested on a different computational path
  - The string in tape $2$ is of the form $w_1 w_3$
  - $q_5$ checks that $w_1w_3=w_2$, and if so we end up in $q_{accept}$
    This mean that strings of the form $w_1 w_2 w_3$ s.t. $w_2=w_1 w_3, \quad w_1,w_2,w_3 \in \{a,b,c\}^+$ are part of the language
We then conclude that the language decided by the machine is $L=\{w_1w_2w_3|w_1,w_2,w_3 \in \{a,b,c\}^*,\quad w_2=w_1w_3\}$.

*** Deterministic or nondeterministic?

We are dealing with a nondeterministic Turing machine: fore example we have a nondeterministic behaviour between $q_2$ and $q_3$, where with input $(q_2,\alpha,\_,\_)$ we can either stay in $q_2$ or move to $q_3$.

*** Running time

By running a nondeterministic machine we generate a computation tree that, in the case of parallel running, has a running time equivalent to the longest possible computation branch.
- From $q_1$ to $q_2$ the input head doesn't move, so its constant time w.r.t. input
- From $q_2$ to $q_5$ the input head always moves one step right by each iteration, so $O(n)$
- In $q_5$ we read two tapes at the same time, each with length $n/2$
We then conclude that smallest asymptotic time for this machine is $O(n)$

*** Property

Let $K$ be the language previously described, we consider now the following property $P$

\begin{equation}
P = \{<M>| \text{ every string that }M\text{ accepts is not in }K\}\notag
\end{equation}
\begin{equation}
L=\{w_1w_2w_3|w_1,w_2,w_3 \in \{a,b,c\}^*,\quad w_2=w_1w_3\} \notag
\end{equation}

Remember that in general properties are languages that have as an input the encoding of a Turing machine, and for this reason we can deal with with them by suing specific theoretical tools (e.g. Rice theorem).

Is $P$ non-trivial? So
- Is $P \neq \emptyset$? :: Yes, we can describe a Turing machine that accepts only the string $ab$, and $ab \notin K$.
- $\exists$ a Turing machine $M$ s.t. $M \notin P$? :: Yes, for example the scheme provided at the beginning describes such a machine, or also a Turing machine that just accepts the empty string.
We then conclude that $P$ is non-trivial.

Is $P$ semantic? Remember that $P$ is semantic $\iff$ given $M_1,M_2$ s.t. $L(M_1)=L(M_2)=L$, either $M_1,M_2 \in P$ or $M_1,M_2 \notin P$. Given $L$, we have two consider two cases
- $L \cap K \neq \emptyset \Rightarrow \exists w \in L$ s.t. $w \in K$, so $M_1,M_2 \notin P$
- $L \cap K = \emptyset \Rightarrow w \notin K, \forall w \in L$, so $M_1,M_2 \in P$
We then conclude that $P$ is semantic.

Finally, is
- $P \in \mathbf{R}$? :: So $\exists M$ that decides $P$? No, because we proved that $P$ is semantic and non-trivial and for the Rice's theorem we conclude $P \notin R$
- $P \in \mathbf{RE} \setminus  \mathbf{R}$? :: So $P \notin R$ (just proven) and $\exists M$ that accepts $P$
- $P \notin \mathbf{RE}$? :: So $\nexists M$ that accepts $P$
So $\exists M$ that accepts $P$?
- We may try to build a machine that, for each string accepted by a given TM, answers ~Yes~ if none of them is in $K$. However, this is impossible: the language accepted by the TM may be infinite and $M$ may never halt.
- We can build a machine that answers ~No~ instead: if $\exists w \in K$, at some time $M$ will halt and answer ~No~.
We have proven that $\exists M$ that accepts $\bar{P}$, so $\bar{P} \in \mathbf{RE}$. Note that

\begin{equation}
P,\bar{P} \in \mathbf{RE} \Rightarrow P,\bar{P} \in \mathbf{R} \notag
\end{equation}

But we have proven both that $P \notin \mathbf{R}$ and $\bar{P} \in \mathbf{RE}$, so we must conclude that $P \notin \mathbf{RE}$.

** Complexity part
*** $\text{COMPUTERS}$ problem

#+BEGIN_QUOTE
You are given a set $C = \{ 1, \cdots, n \}$ of n computers. These computers are all connected, via the network, to a central storage.

The hard drive of this central storage is divided into $P = \{ 1, \cdots, m \}$ pages.

For each computer $i$ in $C$, you are given the set $D_i$ of pages that the computer $i$ will access on the central storage, when it runs.

Given the set of computers $C$, the set of pages $P$, an integer $k$, and for each computer $i$ in $C$, the set of pages $D_i$ that computer $i$ accesses, the problem $\text{COMPUTERS}$ is to decide whether it is possible to run at least $k$ computers without having any two computers ever accessing the same page.
#+END_QUOTE

We can prove that this language $L$ is in $\mathbf{NP}$ by providing a "guess and check" algorithm, that means provide an algorithm that
1. Guesses a candidate solution for the problem: in this case, a set of computers
2. Verifies that the candidate is a solution: in this case, a set of computers with $k$ computers s.t. no page is shared between any of its elements.

\begin{algorithm}[H]
\SetAlgoLined
\KwData{A set of pages $P$, a set of computers $C$, for each computer $i$ a set of pages $D_i$}
\KwResult{$Y$ if $\exists S \subseteq C$ s.t. $|S| \geq k$ and $D_i \cap D_j = \emptyset, \forall i,j \in S$, $N$ otherwise}
 Guess a set $S \subseteq C$\;
 \If{$|S| < k$}{
  \Return N\;
 }
 \ForAll{$i \in S$}{
   \ForAll{$j \in S$}{
     \If{$i \neq j$ and $D_i \cap D_j = \emptyset$}{
       \Return N\;
     }
   }
 }
 \Return Y\;
 \caption{A guess and check nondeterministic algorithm for the \text{COMPUTERS} problem}
\end{algorithm}

The algorithm is in $\textbf{NP}$ if it runs in polynomial time, Let's check each step
1. Guessing a candidate solution requires to
   1) Copy in a secondary tape one computer at a time
   2) Either stop or copy another computer
   This is done by scanning the input tape in just one direction, so $O(n)$
2. Check $|S| < k$ is done by counting the number of computers in the input tape with one scan, so $O(n)$
3. Verifying the candidate requires polynomial time since
   1) First loop for $i \in S$ is in $O(n)$
   2) Second loop for $j \in S$ is in $O(n)$
   3) Checking $i \neq j$ is done in constant time, $D_i \cap D_j = \emptyset$ requires
      1) First loop for $p \in P_i$ is in $O(m)$
      2) Second loop for $p' \in P_j$ is in $O(m)$
      3) Checking $p \neq p'$ is done in constant time
   This is done in $O(n^2 m^2)$
Overall, we have $O(n+n+n^2 m^2)$. So $\text{COMPUTERS} \in \textbf{NP}$.

To prove $\text{COMPUTERS}$ is $\textbf{NP-hard}$, we need to provide a reduction $L \leq_p \text{COMPUTERS}$ s.t. $L \in \textbf{NP-hard}$. Such reduction should convert an input for $L$ into an input for $\text{COMPUTER}$, in polynomial time.

For example, we can choose $L$ to be Independent Set, $\text{IS}$. Remember that

\begin{equation}
\text{IS}=\{ (G,k') |G \text{ undirected graph}, \exists S \text{ independent set s.t.} |T| \ge k'\} \notag
\end{equation}

And $T$ is an independent set in $G=(V,E)$ if and only if there is no edge connecting any pair of nodes in $T$.

Back to the reduction, we can translate
- Each node $v \in V$ of the graph to a computer $c \in C$
- Each edge $e \in E$ to a page $p \in P$
- Each set of edges $E_v=\{e \in E | e=(v,u) \text{ or } e=(u,v), \quad v,u \in V\}$ for node $v \in V$ to a set of pages $D_i$ that computer $i \in C$ accesses
- The $k'$ of $\text{IS}$ to the $k$ of $\text{COMPUTERS}$

This reduction is valid if $\text{IS}$ has a solution $\iff \text{COMPUTERS}$ has a solution.
- $\text{IS}$ has a solution $\Rightarrow$ $\text{COMPUTERS}$ has a solution. If $T$ is a solution to $\text{IS}$ then
  - $|T| \geq k'$ then $|S| \geq k$
  - $e=(u,v) \notin E , \forall u,v \in T \Rightarrow D_i \cap D_j = \emptyset, \forall i,j \in S$. Proof by contradiction: assume $\exists i,j \in S| D_i \cap D_j \neq \emptyset$: this means that there is an equivalent page $e=D_i \cap D_j$ shared by computers $i,j$ and connected in $T$, but this is impossible if $T$ is an independent set.
-  $\text{COMPUTERS}$ has a solution $\Rightarrow$ $\text{IS}$ has a solution. If $S$ is a solution to $\text{COMPUTERS}$ then
  - $|S| \geq k$ then $|T| \geq k'$
  - $D_i \cap D_j = \emptyset, \forall i,j \in S \Rightarrow e=(u,v) \notin E , \forall u,v \in T$. Proof by contradiction: assume $\exists e=(u,v) \in E | u,v \in T$: this means that there is an equivalent edge $D_u \cap D_v = e$ connecting $u,v$ in $T$ and an equivalent shared page in $S$, but this is impossible if $S$ is a solution for $\text{COMPUTERS}$.
Having proved both directions, we conclude that the reduction is correct.

Also, the reduction is in polynomial time: starting from the graph $G$, it copies
- The $n$ nodes to build $C$
- The $m$ edges to build $P$
- The $n*m$ (in the worst case) to build $D_i, \forall i \in C$
So we deal with a $O(n + m + n m)$ algorithm.

The reduction is correct and works in polynomial time, so $\text{COMPUTERS} \in \textbf{NP-hard}$, and since we already proved that $\text{COMPUTERS} \in \texbf{NP}$ we can also conclude that $\text{COMPUTERS} \in \textbf{NP-complete}$.

*** Search version of $\text{COMPUTERS}$

Considering the problem $\text{COMPUTERS}$, we ask ourself what is the maximum number of computers we can turn on?
The idea is to use $\text{COMPUTERS}$ as an oracle

\begin{algorithm}[H]
\SetAlgoLined
\KwData{A set of pages $P$, a set of computers $C$, for each computer $i$ a set of pages $D_i$}
\KwResult{The maximum number of computers $k$ we can turn on}
 k=0\;
 \While{$k \leq |e|$ and $(C,P,D_i,k) \in \text{COMPUTERS}$}{
  k++\;
 }
 \Return k-1\;
 \caption{\text{MAX-COMPUTERS} - search version of the \text{COMPUTERS} problem}
\end{algorithm}

The algorithm requires polynomial time with an oracle for COMPUTERS. Since the algorithm solves a search problem, we say that $\text{MAX-COMPUTERS} \in \textbf{FP}^{\textbf{NP}}$.

But is this the smallest complexity class? Actually, we can improve the previous algorithm by applying binary search, that uses a logarithmic number of calls: so in fact  $\text{MAX-COMPUTERS} \in \textbf{FP}^{\textbf{NP} [\log n]}$.

* Useful references
- [[https://plato.stanford.edu/entries/computability/][Stanford Encyclopedia of Philosophy]]
