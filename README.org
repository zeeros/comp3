#+TITLE: Notes on Computability and Computational Complexity

Collection of notes and code about the Computability and Computational Complexity course, part of the Master in Computer Science at the Universit√† di Trento (UNITN).

* Computational Complexity
** $\text{DTIME}$ and $\text{NTIME}$, $\textbf{P}$ and $\textbf{NP}$

From now on we will focus our attention on the class of decidable problems $R=\{L|\exists \text{ Turing machine } M \text{ that decides } L \}$. Considering the languages that can be decided in $O(f(n)), f: \mathbb{N} \rightarrow \mathbb{N}$, we have
- $\text{DTIME}(f(n))=\{L|L\in R, T_M(n)\in O(f(n))\}$, solvable by a deterministic TM.
- $\text{NTIME}(f(n))=\{L|L\in R, NT_M(n)\in O(f(n))\}$, solvable by a nondeterministic TM.

Considering only the languages that can be decided in polynomial time, we have the following complexity classes
- $\textbf{P} = \bigcup_{c\geq 1} \text{DTIME}(n^c)$, problems solvable by a deterministic TM in polynomial time.
- $\textbf{NP} = \bigcup_{c\geq 1} \text{NTIME}(n^c)$, problems solvable by a nondeterministic TM in polynomial time.

Nondeterministic TMs are often devised using a /trail and error/ (or guess and check) approach, where the resulting computation takes the form of a decision tree model.  To check if $w \in L$, the NTM should
1. Guess a /certificate/ (some data) on the tape, in polynomial time.
2. Check the certificate to proove $w \in L$, in polynomial time.

The class $\mathbf{PC}$ collects the languages that can be decided with such NTMs, and it is in fact an alternative definition of $\mathbf{NP}$ since $\mathbf{PC}=\mathbf{NP}$.

** $\textbf{P}$ languages
*** Reachability

\begin{equation}
\text{REACHABILITY}=\{(G,s,t)| \exists \text{ a path from node } s \text{ to node } t \text{ in the directed graph } G\} \notag
\end{equation}

\begin{algorithm}[H]
\SetAlgoLined
\KwData{Directed graph $G=(V,E)$ and nodes $s,t$}
\KwResult{$Y$ if there is a path from $s$ to $t$, $N$ otherwise}
 \tcp{Done in constant time w.r.t. input size}
 init an empty queue $Q$\;
 mark node $s$ as $visited$\;
 append $s$ to $Q$\;
 \tcp{At most $|V|$ iterations, visiting all the nodes in $G$}
 \While{$Q$ is not empty}{
  extract node $v$, the first element of $Q$\;
  \If{$v$ is $t$}{
   \Return Y\;
   }
  \tcp{At most $|V|$ iterations, all the the nodes are neighbours of $v$}
  \ForAll{$(v,u) \in E$ s.t. $u$ is not $visited$}{
   mark node $u$ as $visited$\;
   append $u$ to $Q$\;
  }\EndFor
 }
 \Return $N$\;
 \caption{Breadth-first search, in $O(n^2)$ with $n=|V|$}
\end{algorithm}

*** Prime

The algorithm below is not polynomial in the /size of the input/: since the input has been encoded in binary, we use $n=\left\lceil \log_2 N \right\rceil$ bits to encode $N$. This means that $N \in O(2^n)$ and the algorithm is exponential w.r.t to the input size. In the early 2000s a far more complex algorithm has been designed to prove that $\text{PRIME} \in \mathbf{P}$.

\begin{equation}
\text{PRIME}=\{<N>|N\text{ is prime}\},\quad <N>\text{ binary encoding of }N \in \mathbb{N} \notag
\end{equation}

\begin{algorithm}[H]
\SetAlgoLined
\KwData{$<N>$}
\KwResult{$Y$ if $N$ is prime, $N$ otherwise}
 \tcp{At most $N$ iterations}
 \ForAll{$k=2$ to $N-1$}{
  \If{$k$ divides $N$}{
   \Return $N$\;
  }
 }\EndFor
 \Return $Y$\;
 \caption{Naive iteration, in $O(N)$}
\end{algorithm}

** $\mathbf{NP-complete}$ languages

A language $L$ is said to be $\mathbf{NP-complete}$ if and only by providing a polynomial-time algorithm to decide $L$ one proves that every language in $\mathbf{NP}$ can be decided in polynomial time.  For the study of  $\mathbf{NP-completeness}$ we need to introduce some useful concepts. 
- Language $L_1$ reduces to language $L_2$ in polynomial time ($L_1 \leq_p L_2$) if there is a /polynomial-time reduction/ $M$ such that $T_M(n) \in O(n^c), \ c>0$.
- A language $L$ is $\mathbf{NP-hard}$ if $L' \leq_p L \ \forall L' \in \mathbf{NP}$.
- $L \in \mathbf{NP-complete} \Rightarrow L \in \mathbf{NP} \wedge L \in \mathbf{NP-hard}$.
- $L \in \mathbf{NP-complete} \wedge L \in \mathbf{P} \iff \mathbf{P} = \mathbf{NP}$. In other words, deciding an $\mathbf{NP-complete}$ problem in polynomial time proves that $\mathbf{P} = \mathbf{NP}$.
- $L_1 \in \mathbf{NP-hard} \wedge L_1 \leq_p L_2 \Rightarrow L_2 \in \mathbf{NP-hard}$.
- Cook's theorem states that $\text{SAT} \in \mathbf{NP-complete}$.

So to prove a language $L$ is $\mathbf{NP-complete}$ it is enough to show that
1. $L \in \mathbf{NP}$.
2. $L \leq_p L'$, where $L' \in \mathbf{NP-hard}$.

*** SAT

A CNF (/Conjunctive Normal Form/) is a boolean formula of the form $C_1 \wedge C_2 \wedge \cdots \wedge C_n$, with clauses $C_i=(l_1 \vee l_2 \vee \cdots \vee l_k)$ and literals $l_j$. A CNF is satisfiable if there is a truth assignment $\tau$ that makes $\varphi$ true.

Example: For $\varphi=(x_1 \vee x_2 \vee x_2 \vee \bar{x}_3) \wedge (x_4 \vee \bar{x}_5) \wedge (x_1 \vee \bar{x}_5)$ a truth assignment that satisfies $\varphi$ is $\tau: x_1\rightarrow 1, x_2,x_3,x_4,x_5 \rightarrow 0$.

Consider the decision problem $\text{SAT}=\{\varphi|\varphi \text{ is a satisfiable CNF}\}$. Given a CNF $\varphi$ and a truth assignment $\tau$, we can provide an algorithm that checks if $\tau$ satisfies $\varphi$ in polynomial time.

\begin{algorithm}[H]
\SetAlgoLined
\KwData{A CNF boolean formula $\varphi$ and a truth assignment $\tau$}
\KwResult{$Y$ if $\tau$ satisfies $\varphi$ $N$ otherwise}
 \tcp{At most $m$ iterations, checking all the clauses}
 \ForAll{$C_i$ of $\varphi$}{
  $cvalue = False$\;
  \tcp{At most $c$ iterations, checking all the literals}
  \ForAll{$l_j$ of $C_i$}{
   \If{$l_j = True$}{
    $cvalue = True$\;
    break\;
   }
  }
  \If{cvalue = False}{
   \Return $N$\;
  }
 }
 \Return $Y$\;
 \caption{Naive iterations for $\tau$, in $O(m \cdot n)$ with $m$ clauses and $c$ maximum number of literals in a clause}
\end{algorithm}

However, a CNF with $n$ boolean variables has a total of $2^n$ possible truth assignment, making the overall procedure exponential in time. No polynomial procedure has been devised to date.

Can we get a better result by relying on non-determinism? We can use a /trial and error/ approach with a NTM that, given a CNF $\varphi$ with variables $x_1, \cdots, x_n$
1. Makes a non-deterministic guess $\tau$ for $x_1,\cdots , x_n$, written on the tape using $n$ bits (the i-th bit represents the assignment for $x_i$ ). Each guess takes a different path on the computational tree and writes polynomially many symbols in the tape.
2. Verifies in polynomial time that $\tau$ satisfies $\varphi$, if so accept (otherwise reject).

By providing a NTM that decides $\text{SAT}$, we proved that $\text{SAT} \in \mathbf{NP}$. 

As already said, Cook's theorem states that $SAT \in \mathbf{NP-complete}$, but even simplified versions are still in $\mathbf{NP-complete}$.
- $\text{3-SAT}=\{\varphi | \varphi \text{ is a boolean formula in 3-CNF that is satisfiable}\}$, where 3-CNF is a CNF whose clauses have at most three literals.
- $\text{EXACT-3-SAT}=\{\varphi | \varphi \text{ is a boolean formula in EXACT-3-CNF that is satisfiable}\}$, where EXACT-3-CNF  is a CNF whose clauses have exactly three literals.

*** Independent set

Given an undirected graph $G=(V,E)$, $S$ is an /independent set/ in $G$ if and only if there is no edge connecting any pair of nodes in $S$.
We are interested in the decision problem $\text{IS}=\{ (G,K) |G \text{ undirected graph}, \exists S \text{ independent set s.t. |S|} \ge k\}$ is also $\textbf{NP-complete}$. While we can provide an algorithm that checks if $S$ is an independent set of $G$ in polynomial time, the total number of possible sets of nodes for a graph $G$ is  $\sum_{i=k}^{n} \binom{n}{i}$. Our procedure is not polynomial in time and no polynomial procedure has been devised to date.

\begin{algorithm}[H]
\SetAlgoLined
\KwData{Undirected graph $G$, cardinality $k$}
\KwResult{$Y$ if $G$ contains an indipendent set $S$ s.t. $|S| \geq k$, $N$ otherwise}
 \tcp{At most $\sum_{i=k}^{n} \binom{n}{i}$ iterations, checking all the possible sets with at least $k$ nodes}
 \ForAll{Set of nodes $S$ s.t. $|S| \geq k$}{
  \tcp{At most $n(n-1)/2$ iterations, checking all the pairs when $|S|=n$}
  \ForAll{$(u,v) \in S$}{
   \If{$(u,v)$ are connected}{
    break\;
   }
  }
  \Return $Y$\;
 }
 \Return $N$\;
 \caption{Naive iterations, in $O(n^2 \sum_{i=k}^n \frac{n!}{i!(n-i)!})$ with $n$ nodes}
\end{algorithm}

Similarly to $\text{SAT}$, we can also devise a NTM that uses a trial and error strategy. Given an undirected graph $G$ with $n$ nodes and a number $k$
1. For each node $v$ in $G$, non-deterministically decide to write or not $v$ in the tape.
2. Accept if at least $k$ nodes have been written and no two of them are connected (otherwise reject).

By providing a NTM that decides $\text{IS}$, we proved that $\text{IS} \in \mathbf{NP}$.  To proove that $\text{IS} \in \mathbf{NP-hard}$ (and $\mathbf{NP-complete}$) we can provide a polynomial-time reduction for  $\text{EXACT-3-SAT} \leq_p \text{IS}$.

*** Vertex cover

Given an undirected graph  $G=(V,E)$, $VC \subseteq V$ is a /vertex cover/ if and only if all the vertices of $G$ are touched by some node in $VC$. We set the decision problem $\text{VCOVER}=\{(G,k)|G \text{ undirected graph }, \exists VC \text{ vertex cover s.t. } |VC| \leq k\}$ and we want to prove $\text{VCOVER}\in \mathbf{NP-complete}$.

For this problem we can rely on one important observation: let  $G=(V,E)$ be an undirected graph and $S \subseteq V$ a set of nodes, then $S$ is an independent set in $G$ if and only if $V\setminus S$ is a vertex cover of $G$.

We first proove that $\text{VCOVER} \in \textbf{NP}$ by devising a NTM that
- Makes a non-deterministic guess of at most $k$ nodes in its tape in polynomial time.
- Verifies in polynomial time that all edges are covered.

To proove that $\text{VCOVER} \in \mathbf{NP-hard}$ we can define a polynomial reduction for $\text{IS} \leq_p \text{VCOVER}$. We must devise a reduction that converts a pair $(G,k)$ to a pair $(G',k')$: if $G$ has an independent set with at least $k$ nodes, then $G'$ has a vertex cover with at most $k'$ nodes (and vice versa). So the reduction constructs $G'=G$ and $k'=|V|-k$ in a way that
- If $G$ has an independent set $S$ with $|S| \geq k$, then (for the previous observation) $V\setminus S$ is a vertex cover of $G$ (and thus of $G'$). And since $|S| \geq k$, then $|VC|=|V \setminus S | \leq |V|-k=k'$.
- If $G'$ has a vertex cover $VC$ with $|VC|<k'$, then $S=V \setminus VC$ is an independent set of $G'$ (and thus of $G$). And since $|VC|<k'$, then $|S|=|v \setminus VC| \geq |V| - k' = k$.

Then we have also proven that $\text{VCOVER} \in \mathbf{NP-complete}$.

*** Clique

Given an undirected graph $G=(V,E)$, $C \in V$ is a /clique/ if and only if the nodes in $C$ form a fully connected subgraph in $G$. We consider the decision problem $\text{CLIQUE}=\{(G,k)|G \text{ undirected graph }, \exists C \text{ clique s.t. } |VC| \geq k\}$.

For this problem we can exploit the fact that an independent set $S$ in $G$ corresponds to a clique in a graph $\overline{G}$, with $\overline{G}$ being the complement of $G$ (any pair of nodes $G$ is adjacent iff it's not adjacent in $\overline{G}$).

We first proove that $\text{CLIQUE} \in \textbf{NP}$ by devising a NTM that
- Makes a non-deterministic guess of at lest $k$ nodes in its tape in polynomial time.
- Verifies in polynomial time that all pairs are connected.

To proove that $CLIQUE \in \mathbf{NP-hard}$ we can define a polynomial reduction for $IS \leq_p CLIQUE$. We must devise a reduction that converts a pair $(G,k)$ to a pair $(G',k')$: if $G$ has an independent set with at least $k$ nodes, then $G'$ has a clique with at least $k'$ nodes (and vice versa). So the reduction constructs $G'=\overline{G}$, by copying $|V|$ nodes and adding at most $|V|^2$, and $k'=k$ in a way that
- If $G$ has an independent set $S$ with $|S| \geq k$, then (for the previous observation) $S$ is a clique of $G'$  with at least $k=k'$ nodes in $G'$.
- If $G'$ has a clique $C$ with at least $k'$ nodes, then no distinct nodes in $G$ are connected in $G'$ and $C$ is an independent set with at least $k'=k$ nodes in $G$.

*** Binary integer programming

$A \in \mathbb{Z}^{m \times n}$ and $\bar{b} \in \mathbb{Z}^m$ contain respectively the coefficients $a_{ij} \in \mathbb{Z}$ and $b_i \in \mathbb{Z}$ of a system of linear inequalities, and to solve the system means finding a $\bar{x}$ s.t. $A \cdot \bar{x} \leq \bar{b}$.

\begin{equation}
\text{BIP} = \{(A,\bar{b})|A \in \mathbb{Z}^{m \times n}, \bar{b} \in \mathbb{Z}^m, \exists \bar{x}\in \{0,1\}^n | A \cdot \bar{x} \leq \bar{b}\} \notag
\end{equation}

$\text{BIP} \in \textbf{NP-complete}$ since
1. $\text{BIP} \in \textbf{NP}$
2. $\text{BIP} \in \textbf{NP-hard}$, we can define a polynomial reduction $\text{EXACT-3-SAT} \leq_p \text{BIP}$

Also the more general version of the problem $\text{IP} = \{(A,\bar{b})|A \in \mathbb{Z}^{m \times n}, \bar{b} \in \mathbb{Z}^m\} \notag \in \textbf{NP-complete}$

*** Vertex coloring

Given an undirected graph $G=(V,E)$ and $k \in \mathbb{Z}$, a function $\text{k-coloring}: V \rightarrow \{1,2,\dots,k\}$ assigns a color to each node so that $f(u) \neq f(v), \forall \{u,v\} \in E$.

\begin{equation}
\text{VCOL} = \{(G,k)|G \text{ is an undirected graph admitting a k-coloring}\} \notag
\end{equation}

$\text{VCOL} \in \textbf{NP-complete}$ since
1. $\text{VCOL} \in \textbf{NP}$
2. $\text{VCOL} \in \textbf{NP-hard}$, we can define a polynomial reduction $\text{EXACT-3-SAT} \leq_p \text{VCOL}$

Also the more specific version of the problem $\text{3-VCOL} = \{(G,k)|G \text{ is an undirected graph admitting a 3-coloring}\}$

** $\mathbf{coNP}$

Similarly to the $RE$ languages case, the complement of languages in
$\mathbf{NP}$ present an asymmetric behaviour. Considering a NTM
- Accepting requires /at least/ one accepting path
- Rejecting requires /all paths/ to be rejecting

We define the complexity class containing the complements of $\mathbf{NP}$ languages as $\mathbf{coNP} = \{L|\bar{L} \in \mathbf{NP}\}$: note that this is not $L|L \notin \mathbf{NP}$, so $\exists L \in \mathbf{NP} \cap \mathbf{coNP}$. While we still don't know if $\mathbf{NP} = \mathbf{coNP}$, some theorems can help us  to tackle this question
- $\mathbf{NP} = \mathbf{coNP} \iff \exists L \in \mathbf{NP-complete} \cap \mathbf{coNP}$
- $\mathbf{P} \subseteq \mathbf{NP} \cap \mathbf{coNP}$
- $\mathbf{P} = \mathbf{NP} \Rightarrow \mathbf{NP} = \mathbf{coNP}$

*** Factor

\begin{equation}
\text{FACTOR}=\{(N,K)|N \in \mathbb {N} \text{ with at least a prime factor } M \leq k\} \notag
\end{equation}

This is an example of problem in a "/limbo/" between $\mathbf{P}$ and $\mathbf{NP-complete}$, in fact $\text{FACTOR} \in \mathbf{NP} \cap \mathbf{coNP}$. We don't know if $\text{FACTOR} \notin \mathbf{P}$, but the current cryptography field is based on this belief: finding a key of a channel is equivalent to factorize a very large $N$.

** $\textbf{EXP}$ and $\textbf{NEXP}$

Considering the languages that can be decided in exponential time, we have the following complexity classes
- Exponential time $\textbf{P} = \bigcup_{c\geq 1} \text{DTIME}(2^{n^c})$, solvable by a deterministic Turing machine
- Nondeterministic exponential time $\textbf{NP} = \bigcup_{c\geq 1} \text{NTIME}(2^{n^c})$, solvable by a non-deterministic Turing machine

** $\text{DSPACE}$ and $\text{NSPACE}$

We now consider a two-tapes Turing machine with a read-only /input tape/ and a read-write /working tape/, with no need to output anything. The space required by such machine is denoted as $S_M(n)$, the maximum number of cells visited on the working tape for an input of lenght $n$. In the non-deterministic case we must consider all the computation paths.

Let $f: \mathbb{N} \rightarrow \mathbb{N}$, we have
- $\text{DSPACE}(f(n))=\{L|\exists T_M \text{ deciding } L, S_M(n) \in O(f(n))\}$, solvable by a non-deterministic Turing machine using space in the order of $f(n)$.
- $\text{NSPACE}(f(n))=\{L|\exists NT_M \text{ deciding } L, S_M(n) \in O(f(n))\}$, solvable by a non-deterministic Turing machine using space in the order of $f(n)$.

** $\textbf{LOGSPACE}$ and $\textbf{NL}$

Considering only the languages that can be decided with a logarithmic amount of space, we have the following complexity classes
- Logspace $\textbf{LOGSPACE} = \text{DSPACE}(\log n)$, solvable by a deterministic Turing machine
- Nondeterministic logspace $\textbf{NL} = \text{NSPACE}(\log n)$, solvable by a non-deterministic Turing machine

For sure $\textbf{LOGSPACE} \subseteq \textbf{NL}$, but is $\textbf{LOGSPACE}=\textbf{NL}$? This is still an open question
- $L_1 \leq_L L_2$ is a logspace reduction
- A language $L\in \textbf{NL-complete} \iff L \in \textbf{NL} \wedge L' \leq_L L, \forall L'\in \textbf{NL}$.
- We know that $\textbf{LOGSPACE} = \textbf{NL} \iff \exists L | L \in \textbf{LOGSPACE} \wedge L \in \textbf{NL-complete}$.

*** $L_{01} \in \mathbf{LOGSPACE}$ 

\begin{equation}
L_{01} = \{ 0^n1^n | n \geq 0\} \notag
\end{equation}

\begin{algorithm}[H]
\SetAlgoLined
\KwData{Input string $w$}
\KwResult{$Y$ if $w=0^n1^n$, $N$ otherwise}
 \If{w=\{\}}{
  \Return $Y$\;
 }
 $zero\_counter=0$\;
 \While{$input\_cell$ is 0}{
  $zero\_counter=zero\_counter + 1$\;
  read next $input\_cell$\;
 }
 $one\_counter=0$\;
 \While{$input\_cell$ is 1}{
  $one\_counter=one\_counter + 1$\;
  read next $input\_cell$\;
 }
 \eIf{$input\_cell=\_$ and $zero\_counter=one\_counter$}{
  \Return $Y$\;
 }{
  \Return $N$\;
 }
 \tcp{Only two counters are used, each at most $n=|w|$, encoded in binary so $O(\log_2 n)$}
 \caption{Turing machine for $L_{01}$, $S_M(n) \in O(\log_2 n) \Rightarrow L_{01} \in \mathbf{LOGSPACE}$}
\end{algorithm}

*** $\text{REACHABILITY} \in \mathbf{NL-complete}$

\begin{equation}
\text{REACHABILITY} = \{(G,s,t)|\text{ directed graph } G \text{ has a path from } s \text{ to } t\} \notag
\end{equation}

Note that we can store into the working tape a pointer with the position of the input string in the input tape: this pointer would take only $O(\log_2 |w|)$ cells instead of holding the entire string in $O(|w|)$.

\begin{algorithm}[H]
\SetAlgoLined
\KwData{Directed graph $G=(V,E)$ and nodes $s,t$}
\KwResult{$Y$ if there is a path from $s$ to $t$, $N$ otherwise}
 $p$ points to $s$, store $p$ in the working tape\;
 $counter=1$, store $counter$ in the working tape\;
 \#LABEL\;
 \If{$p$ points to $t$}{
  \Return $Y$\;
 }
 Guess a point $v$ in $G$, $p'$ points to $v$\;
 \If{$p$ points to a node with no edge to the node pointed by $p'$}{
  \Return $N$\;
 }
 $p=p'$\;
 $counter=counter+1$\;
 \eIf{counter \leq |V|}{
  \textbf{goto} \#LABEL\;
 }{
  \Return $N$\;
 }
 \caption{Algorithm for $\text{REACHABILITY} \in \mathbf{NL}$}
\end{algorithm}

Furthermore, $\text{REACHABILITY} \in \textbf{NL-complete}$.

** Savitch's Theorem

\begin{equation}
\text{NSPACE}(f(n)) \subseteq \text{DSPACE}(f^2(n)) \quad \forall n \in \mathbb{N}, \forall f:\mathbb{N} \rightarrow \mathbb{N}| f(n) \geq \log n \notag
\end{equation}

When considering space, there is in fact not much difference between deterministic and non-deterministic Turing machines: unlike time, space can be reused.

*** $\mathbf{PSPACE}$ and $\mathbf{NPSPACE}$

\begin{equation}
\mathbf{PSPACE}=\bigcup_{c \geq 1} \text{DSPACE}(n^c),\quad  \mathbf{NSPACE}=\bigcup_{c \geq 1} \text{DSPACE}(n^c) \notag
\end{equation}

From the Savitch's theorem, the following corollary over (at least) polynomial space follows

\begin{equation}
\mathbf{PSPACE} = \mathbf{NPSPACE} \notag
\end{equation}

*** $\text{REACHABILITY} \in \text{DSPACE}((\log_2 n)^2)$

\begin{algorithm}[H]
\SetAlgoLined
\KwData{Directed graph $G=(V,E)$, nodes $s,t$ and an integer $k$}
\KwResult{$Y$ if there is a path from $s$ to $t$ requiring at most $k$ steps, $N$ otherwise}
 \tcp{Does $s$ reach $t$ in zero steps?}
 \If{$k=0$}{
  \eIf{$s=t$}{
   \Return $Y$\;
  }{
   \Return $N$\;
  }
 }

 \tcp{Does $s$ reach $t$ in at most one step?}
 \If{k=1}{
  \eIf{$s=t$ or $(s,t) \in E$}{
   \Return $Y$\;
  }{
   \Return $N$\;
  }
 }

 \tcp{Look for a middle node}
 \ForEach{$u \in V$}{
  \eIf{$\text{exists-path}(G,s,u,\left\lfloor k/2 \right\rfloor)$ and $\text{exists-path}(G,s,u,\left\lceil k/2 \right\rceil)$}{
   \Return $Y$\;
  }{
   \Return $N$\;
  }
 }
 \Return $N$\;
 \caption{\text{exists-path}}
\end{algorithm}

** Overview on time and space complexity classes

Considering space classes, we have $\mathbf{LOGSPACE} \subseteq \mathbf{NL} \subseteq \mathbf{PSPACE} = \mathbf{NPSPACE}$, and their relationship with time classes is as follows
- $\mathbf{LOGSPACE}\math \subseteq \mathbf{P}, \quad \mathbf{NL} \subseteq \mathbf{P}$
- $\mathbf{NP} \subseteq \mathbf{PSPACE}, \quad \mathbf{coNP} \subseteq \mathbf{PSPACE}$
- $\mathbf{PSPACE} \subseteq \mathbf{EXP}$

** Turing Machines with Oracles

\begin{equation}
\text{MIN-COVER}=\{(G,k)|\text{ undirected graph } G, \text{ the smallest vertex cover } VC \text{ is } |VC|=k\} \notag
\end{equation}

Our procedure should both verify that there is a vertex cover of size at most $k$ ($\text{VCOVER} \in \textbf{NP}$) and no vertex cover of size $k-1$ ($\overline{\text{VCOVER}} \in \textbf{coNP}$): we believe that $\textbf{NP} \neq \textbf{coNP}$, so unlikely this can be done in $\textbf{NP}$. We can rephrase the problem as

\begin{equation}
\text{MIN-COVER}=\{(G,k)|(G,k) \in \text{VCOVER} \wedge (G,k-1) \notin \text{VCOVER}\} \notag
\end{equation}

Given a procedure $\text{check-cover}$ deciding $\text{VCOVER}$, we can call it as a sub-routine (an /oracle/). We only need a polynomial number of steps to decide $\text{MIN-cover}$, but the most difficult part done by the oracle.

A Turing machine with an /oracle/ for $L$ has an additional read/write tape, oracle tape, and three more states $q_?, q_{yes}, q_{not}$. To check if $w \in L$, write $w$ in the oracle tape and move to $q_?$: if the next state is $q_{yes}$, then $w \in L$.

Using oracles we can define different complexity classes. Le $C$ be some complexity class
- $\textbf{P}^C=\{L\L \text{ can be decided by a polynomial time } DTM \text{ with an oracle for some language } L' \in C\}$
- $\textbf{NP}^C=\{L\L \text{ can be decided by a polynomial time } NTM \text{ with an oracle for some language } L' \in C\}$

For example, $\text{MIN-VCOVER} \in \texbf{P}^\textbf{NP}$. Note that $\textbf{NP} \subseteq \textbf{P}^\textbf{NP}$ and $\textbf{coNP} \subseteq \textbf{P}^\textbf{NP}$. Using oracles we can also define a /polynomial time heriarchy/, wich is an infinite hiearchy of complexity classes.

** Search problems with decision version

\begin{equation}
\text{FMIN-VCOVER}=\min\{|VC|| VC\text{ is a vertex cover of }G\}\notag
\end{equation}

\begin{algorithm}[H]
\SetAlgoLined
 $k = |V| - 1$\;
 \While{(G,k) \in \text{VCOVER}}{
  k = k -1
 }
 write $k$ in the output tape
\end{algorithm}

Let $\mathbf{FP}$ be the class of search problems that can be solved by a Turing machine with output tape in polynomial time, then $\text{FMIN-VCOVER} \in \textbf{FP}^\textbf{NP}$. We can actually improve the previous algorithm by employing binary search and reducing the number of steps from $O(|V|)$ to $O(\log_2 |V|)$, so $\text{FMIN-VCOVER} \in \textbf{FP}^{\textbf{NP} \left[ \log_2 n \right]}$.

** The Travelling Salesman Problem

We define the /Functional Travelling Salesman Problem/ (FTSP) as, given a weighted undirected graph, finding the minimum cost of an Hamilton cycle (if it exists).

\begin{equation}
\text{TSP} = \{(G,K)|\text{ weighted, undirected graph } G \text{ with an Hamilton cycle costing at most } k\} \notag
\end{equation}

\begin{algorithm}[H]
\SetAlgoLined
 \tcp{$m$ bits to encode each cost + $|E|$ bits to encode each edge $\rightarrow k \in O(2^{m+|E|})$}
 $k$ is the sum of the cost of all edges in $G$\;
 \If{(G,k) \notin \text{TSP}}{
  write $\bot$ in the output tape and halt\;
 }
 \While{(G,k) \in \text{TSP}}{
  $k=k-1$\;
 }
 write $k+1$ in the output tape\;
\end{algorithm}

A better algorithm relies again on binary search, resulting in $\text{FTSP} \in \textbf{FP}^{\textbf{NP}}$.

\begin{algorithm}[H]
\SetAlgoLined
 $a = 0$\;
 \tcp{$m$ bits to encode each cost + $|E|$ bits to encode each edge $\rightarrow b \in O(2^{m+|E|})$}
 $b$ is the sum of the cost of all edges in $G$\;
 \tcp{ binary search, so number of iterations $\in O(\log_2 2^{m+|E|})=O(m+|E|)$}
 \While{a \leq b}{
  $k = \left\lfloor (a+b)/2 \right\rfloor$\;
  \eIf{$(G,k-1) \in \text{TSP}$}{
   \tcp{Cost is striclty smaller than middle point, move interval to the left}
   $b = k-1$\;
  }{
   \eIf{(G,k) \in \text{TSP}}{
    \tcp{$k$ is the minimum cost}
    write $k$ in the output tape and halt\;
   }{
    \tcp{Cost is striclty larger than middle point, move interval to the right}
    $a = k+1$\;
   }
  }
 }
 write $\bot$ in the output tape\;
\end{algorithm}

Finally, since $\text{TSP} \in \textbf{NP-complete}$ also the specific $\text{FTSP} \in \textbf{NP-complete}$.

* Exam discussion 09/02/2021
** Computability part
*** Describe the language

We first need to identify what is the language decided by the Turing machine represented by the scheme, where $\alpha \in \{a,b,c\}$.

#+CAPTION: The scheme provided for the Turing machine to be discussed
[[./img/tm_09022021.jpg]]

From $q_1$ we go to $q_{accept}$ if the input string is empty, otherwise move to $q_2$.

In $q_2$ we always read a symbol $\alpha$ in tape $1$ and move to the right, then we either
- Copy $\alpha$ to tape $2$, move right and stay in $q_2$
- Copy $\alpha$ to tape $3$, move right and move to $q_3$
Note that this is a nondeterministic behaviour.

In $q_3$ we either
- Keep copying $\alpha$ in tape $3$, moving right and staying in $q_3$
- Copy $\alpha$ to tape $2$, move right in tape $2$, move left in tape $3$ and move to $q_4$
Also here we have a nondeterministic behaviour.

In $q_4$ we keep copying $\alpha$ to tape $2$ until we reach the end of the string in tape $1$.

When we reach $q_5$, the heads of tape $2$ and $3$ are at the end of the respective strings. We loop in $q_5$ to check that $2$ and $3$ have the same string, when we end with the empty symbol we move to $q_{accept}$.

Finally, the arch from $q_3$ to $q_5$ represents the case where we have read all the string in tape $1$ and skip to the checks made by $q_5$.

To undestand the overall behaviour we explore the possible paths to reach $q_{accept}$
- From $q_1$ to $q_{accept}$, so the empty string =-= is part of the language
- $q_1 \rightarrow q_2 \rightarrow q_3 \rightarrow q_5 \rightarrow q_{accept}$
  - $q_2$ copies from tape $1$ to tape $2$, let's call the resulting string in tape $2$ $w_1$
  - $q_3$ copies the part following $w_1$ to tape $3$, let's call it $w_2$
  - The string in tape $1$ is seen as $w_1 w_2$, each possible length of $w_1$ (and $w_2$) is tested on a different computational path
  - $q_5$ checks that $w_1=w_2$, and if so we end up in $q_{accept}$
    This means that strings of the form $w_1w_2$ s.t. $w_1=w_2,\quad w_1,w_2 \in \{a,b,c\}^+$ are part of the language
- $q_1 \rightarrow q_2 \rightarrow q_3 \rightarrow q_4 \rightarrow q_5 \rightarrow q_{accept}$
  - $q_2$ copies from tape $1$ to tape $2$, let's call the resulting string in tape $2$ $w_1$
  - $q_3$ copies the part following $w_1$ to tape $3$, let's call it $w_2$
  - $q_4$ copies the part following $w_2$ to tape $2$, let's call it $w_3$
  - The string in tape $1$ is seen as $w_1 w_2 w_3$, each possible length of $w_1, w_2, w_3$ is tested on a different computational path
  - The string in tape $2$ is of the form $w_1 w_3$
  - $q_5$ checks that $w_1w_3=w_2$, and if so we end up in $q_{accept}$
    This mean that strings of the form $w_1 w_2 w_3$ s.t. $w_2=w_1 w_3, \quad w_1,w_2,w_3 \in \{a,b,c\}^+$ are part of the language
We then conclude that the language decided by the machine is $L=\{w_1w_2w_3|w_1,w_2,w_3 \in \{a,b,c\}^*,\quad w_2=w_1w_3\}$.

*** Deterministic or nondeterministic?

We are dealing with a nondeterministic Turing machine: we have an example of nondeterministic behaviour between $q_2$ and $q_3$, where with input $(q_2,\alpha,\_,\_)$ we can either stay in $q_2$ or move to $q_3$.

*** Running time

By running a nondeterministic machine we generate a computation tree that, in the case of parallel running, has a running time equivalent to the longest possible computation branch.
- From $q_1$ to $q_2$ the input head doesn't move, so its constant time w.r.t. input
- From $q_2$ to $q_5$ the input head always moves one step right by each iteration, so $O(n)$
- In $q_5$ we read two tapes at the same time, each with length $n/2$
We then conclude that smallest asymptotic time for this machine is $O(n)$

*** Property

Let $K$ be the language previously described, we consider now the following property $P$

\begin{equation}
P = \{<M>| \text{ every string that }M\text{ accepts is not in }K\}\notag
\end{equation}
\begin{equation}
L=\{w_1w_2w_3|w_1,w_2,w_3 \in \{a,b,c\}^*,\quad w_2=w_1w_3\} \notag
\end{equation}

Remember that in general properties are languages that have as an input the encoding of a Turing machine, and for this reason we can deal with with them by using specific theoretical tools (e.g. Rice theorem).

Is $P$ non-trivial? So
- Is $P \neq \emptyset$? :: Yes, we can describe a Turing machine that accepts only the string $ab$, and $ab \notin K$.
- $\exists$ a Turing machine $M$ s.t. $M \notin P$? :: Yes, for example the scheme provided at the beginning describes such a machine, or also a Turing machine that just accepts the empty string.
We then conclude that $P$ is non-trivial.

Is $P$ semantic? Remember that $P$ is semantic $\iff$ given $M_1,M_2$ s.t. $L(M_1)=L(M_2)=L$, either $M_1,M_2 \in P$ or $M_1,M_2 \notin P$. Given $L$, we have two consider two cases
- $L \cap K \neq \emptyset \Rightarrow \exists w \in L$ s.t. $w \in K$, so $M_1,M_2 \notin P$
- $L \cap K = \emptyset \Rightarrow w \notin K, \forall w \in L$, so $M_1,M_2 \in P$
We then conclude that $P$ is semantic.

Finally, is
- $P \in \mathbf{R}$? :: So $\exists M$ that decides $P$? No, because we proved that $P$ is semantic and non-trivial and for the Rice's theorem we conclude $P \notin R$
- $P \in \mathbf{RE} \setminus  \mathbf{R}$? :: So $P \notin R$ (just proven) and $\exists M$ that accepts $P$
- $P \notin \mathbf{RE}$? :: So $\nexists M$ that accepts $P$
So $\exists M$ that accepts $P$?
- We may try to build a machine that, for each string accepted by a given TM, answers =Yes= if none of them is in $K$. However, this is impossible: the language accepted by the TM may be infinite and $M$ may never halt.
- We can build a machine that answers =No= instead: if $\exists w \in K$, at some time $M$ will halt and answer =No=.
We have proven that $\exists M$ that accepts $\bar{P}$, so $\bar{P} \in \mathbf{RE}$. 

Note that $P,\bar{P} \in \mathbf{RE} \Rightarrow P,\bar{P} \in \mathbf{R}$. But we have proven both that $P \notin \mathbf{R}$ and $\bar{P} \in \mathbf{RE}$, so we must conclude that $P \notin \mathbf{RE}$.

** Complexity part
*** $\text{COMPUTERS}$ problem

#+BEGIN_QUOTE
You are given a set $C = \{ 1, \cdots, n \}$ of n computers. These computers are all connected, via the network, to a central storage.

The hard drive of this central storage is divided into $P = \{ 1, \cdots, m \}$ pages.

For each computer $i$ in $C$, you are given the set $D_i$ of pages that the computer $i$ will access on the central storage, when it runs.

Given the set of computers $C$, the set of pages $P$, an integer $k$, and for each computer $i$ in $C$, the set of pages $D_i$ that computer $i$ accesses, the problem $\text{COMPUTERS}$ is to decide whether it is possible to run at least $k$ computers without having any two computers ever accessing the same page.
#+END_QUOTE

We can prove that this language $L$ is in $\mathbf{NP}$ by providing a "guess and check" algorithm, that means provide an algorithm that
1. Guesses a candidate solution for the problem: in this case, a set of computers.
2. Verifies that the candidate is a solution: in this case, a set of computers with $k$ computers s.t. no page is shared between any of its elements.

\begin{algorithm}[H]
\SetAlgoLined
\KwData{A set of pages $P$, a set of computers $C$, for each computer $i$ a set of pages $D_i$}
\KwResult{$Y$ if $\exists S \subseteq C$ s.t. $|S| \geq k$ and $D_i \cap D_j = \emptyset, \forall i,j \in S$, $N$ otherwise}
 Guess a set $S \subseteq C$\;
 \If{$|S| < k$}{
  \Return N\;
 }
 \ForAll{$i \in S$}{
   \ForAll{$j \in S$}{
     \If{$i \neq j$ and $D_i \cap D_j = \emptyset$}{
       \Return N\;
     }
   }
 }
 \Return Y\;
 \caption{A guess and check nondeterministic algorithm for the \text{COMPUTERS} problem}
\end{algorithm}

The algorithm is in $\textbf{NP}$ if it runs in polynomial time, Let's check each step
1. Guessing a candidate solution requires to
   1) Copy in a secondary tape one computer at a time
   2) Either stop or copy another computer
   This is done by scanning the input tape in just one direction, so $O(n)$
2. Check $|S| < k$ is done by counting the number of computers in the input tape with one scan, so $O(n)$
3. Verifying the candidate requires polynomial time since
   1) First loop for $i \in S$ is in $O(n)$
   2) Second loop for $j \in S$ is in $O(n)$
   3) Checking $i \neq j$ is done in constant time, $D_i \cap D_j = \emptyset$ requires
      1) First loop for $p \in P_i$ is in $O(m)$
      2) Second loop for $p' \in P_j$ is in $O(m)$
      3) Checking $p \neq p'$ is done in constant time
   This is done in $O(n^2 m^2)$
Overall, we have $O(n+n+n^2 m^2)$. So $\text{COMPUTERS} \in \textbf{NP}$.

To prove $\text{COMPUTERS}$ is $\textbf{NP-hard}$, we need to provide a reduction $L \leq_p \text{COMPUTERS}$ s.t. $L \in \textbf{NP-hard}$. Such reduction should convert an input for $L$ into an input for $\text{COMPUTER}$, in polynomial time. For example, we can choose $L$ to be Independent Set, $\text{IS}$. Remember that $\text{IS}=\{ (G,k') |G \text{ undirected graph}, \exists S \text{ independent set s.t.} |T| \ge k'\}$ and $T$ is an independent set in $G=(V,E)$ if and only if there is no edge connecting any pair of nodes in $T$.

Back to the reduction, we can translate
- Each node $v \in V$ of the graph to a computer $c \in C$
- Each edge $e \in E$ to a page $p \in P$
- Each set of edges $E_v=\{e \in E | e=(v,u) \text{ or } e=(u,v), \quad v,u \in V\}$ for node $v \in V$ to a set of pages $D_i$ that computer $i \in C$ accesses
- The $k'$ of $\text{IS}$ to the $k$ of $\text{COMPUTERS}$

This reduction is valid if $\text{IS}$ has a solution $\iff \text{COMPUTERS}$ has a solution.
- $\text{IS}$ has a solution $\Rightarrow$ $\text{COMPUTERS}$ has a solution. If $T$ is a solution to $\text{IS}$ then
  - $|T| \geq k'$ then $|S| \geq k$
  - $e=(u,v) \notin E , \forall u,v \in T \Rightarrow D_i \cap D_j = \emptyset, \forall i,j \in S$. Proof by contradiction: assume $\exists i,j \in S| D_i \cap D_j \neq \emptyset$: this means that there is an equivalent page $e=D_i \cap D_j$ shared by computers $i,j$ and connected in $T$, but this is impossible if $T$ is an independent set.
-  $\text{COMPUTERS}$ has a solution $\Rightarrow$ $\text{IS}$ has a solution. If $S$ is a solution to $\text{COMPUTERS}$ then
  - $|S| \geq k$ then $|T| \geq k'$
  - $D_i \cap D_j = \emptyset, \forall i,j \in S \Rightarrow e=(u,v) \notin E , \forall u,v \in T$. Proof by contradiction: assume $\exists e=(u,v) \in E | u,v \in T$: this means that there is an equivalent edge $D_u \cap D_v = e$ connecting $u,v$ in $T$ and an equivalent shared page in $S$, but this is impossible if $S$ is a solution for $\text{COMPUTERS}$.
Having proved both directions, we conclude that the reduction is correct.

Also, the reduction is in polynomial time: starting from the graph $G$, it copies
- The $n$ nodes to build $C$
- The $m$ edges to build $P$
- The $n*m$ (in the worst case) to build $D_i, \forall i \in C$
So we deal with a $O(n + m + n m)$ algorithm.

The reduction is correct and works in polynomial time, so $\text{COMPUTERS} \in \textbf{NP-hard}$, and since we already proved that $\text{COMPUTERS} \in \texbf{NP}$ we can also conclude that $\text{COMPUTERS} \in \textbf{NP-complete}$.

*** Search version of $\text{COMPUTERS}$

Considering the problem $\text{COMPUTERS}$, we ask ourself what is the maximum number of computers we can turn on?
The idea is to use $\text{COMPUTERS}$ as an oracle

\begin{algorithm}[H]
\SetAlgoLined
\KwData{A set of pages $P$, a set of computers $C$, for each computer $i$ a set of pages $D_i$}
\KwResult{The maximum number of computers $k$ we can turn on}
 k=0\;
 \While{$k \leq |e|$ and $(C,P,D_i,k) \in \text{COMPUTERS}$}{
  k++\;
 }
 \Return k-1\;
 \caption{\text{MAX-COMPUTERS} - search version of the \text{COMPUTERS} problem}
\end{algorithm}

The algorithm requires polynomial time with an oracle for COMPUTERS. Since the algorithm solves a search problem, we say that $\text{MAX-COMPUTERS} \in \textbf{FP}^{\textbf{NP}}$.

But is this the smallest complexity class? Actually, we can improve the previous algorithm by applying binary search, that uses a logarithmic number of calls: so in fact  $\text{MAX-COMPUTERS} \in \textbf{FP}^{\textbf{NP} [\log n]}$.

* Useful references
- [[https://plato.stanford.edu/entries/computability/][Stanford Encyclopedia of Philosophy]]
